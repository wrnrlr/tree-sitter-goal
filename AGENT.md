# AGENT.md
Help me develop the tree-sitter grammer for the Goal Array Language.

## File Structure

- `grammar.js`: The grammar definition.
- `src/`: Generated parser files (ignore, generated by tree-sitter).
- `test/`: Test files (`.goal` source code).
  - `test/corpus`: tree-sitter parser test, run with `tree-sitter test`
  - `test/highlight`: tree-sitter syntax highlight test files, run with `tree-sitter test`
- `bindings/`: Language-specific bindings.
- `queries/`: Tree-sitter queries for highlighting and indentation.

## Dev Tips

- After changing `./grammar.js` (re)generate the parsers: `tree-sitter generate`
- Test a file `tree-sitter test <file>`

Test common subsections of syntax in the underscore file `test/_.goal`.

## Usefull Links
- [Tree Sitter: Syntax Highlighting](https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html)

## Extra info

### Dyadic expression
Simple dyadic expressions with a binairy operator:

```
1+2
```

### Assignment

```
a:1
```


### Op Assignment

Syntactic suggar for a:a+1

```
a+:1
```

### List Assignment

Assign the numbers 0, 1 and 2 to the names `a`, `b` and `c`:
```
(a;b;c):!3
```

### Index Op Assignment

Increment the item at position 2 in a:

```
a[2]+:1
```

### Fold

Example of a fold of a list of 10 numbers `!10` folded `\` over the addition operator `+`

```
+/!10
```

It should be parsed the same way as the scan `\` adverb.

```
+\!10
```

A inline comment is only when the `/` is preseeded by whitespace.
A line comment is just a line that starts with `/` followed by text.
A Multi line comment starts with line cointainign only `/`

### Call Syntax

Sum of 1 + 2 + 3
```
+[1;2;3]
```

The `:` operator can be called like any other dyadic opeator as idenity function:
```
:[42]
```

Ofcourse a name or lambda can also by called:

```
{x+y}[1;2]
```

```
f[1;2]
```

### Explicit Apply

Apply the number 2 to the lambda `{x+1}`

```
{x+1}@2
```

### Implicit Apply

```
{x+1} 2
```

## Fix this

The lambda argument parsing is broken, the optional first set of square brackets should be the `args` argument names of the function.

Even a simple argument is parsed wrong, the parser currenlty thinks the args is a block:
```
{[a]a}
```

```
(S [0, 0] - [0, 6]
  (E [0, 0] - [0, 6]
    (n [0, 0] - [0, 6]
      (lambda [0, 0] - [0, 6]
        (E [0, 1] - [0, 5]
          (block [0, 1] - [0, 4]
            (E [0, 2] - [0, 3]
              (n [0, 2] - [0, 3]
                (name [0, 2] - [0, 3]))))
          (n [0, 4] - [0, 5]
            (name [0, 4] - [0, 5])))))))
```

Here a more complex example
```
h:{[a;b;c] a+b+b}
```

```
(S [0, 0] - [0, 17]
  (E [0, 0] - [0, 17]
    (nve [0, 0] - [0, 17]
      (n [0, 0] - [0, 1]
        (name [0, 0] - [0, 1]))
      (v [0, 1] - [0, 2]
        (V [0, 1] - [0, 2]))
      (n [0, 2] - [0, 17]
        (lambda [0, 2] - [0, 17]
          (E [0, 3] - [0, 16]
            (block [0, 3] - [0, 10]
              (E [0, 4] - [0, 9]
                (n [0, 4] - [0, 5]
                  (name [0, 4] - [0, 5]))
                (n [0, 6] - [0, 7]
                  (name [0, 6] - [0, 7]))
                (n [0, 8] - [0, 9]
                  (name [0, 8] - [0, 9]))))
            (nve [0, 10] - [0, 16]
              (n [0, 10] - [0, 12]
                (name [0, 10] - [0, 12]))
              (v [0, 12] - [0, 13]
                (V [0, 12] - [0, 13]))
              (nve [0, 13] - [0, 16]
                (n [0, 13] - [0, 14]
                  (name [0, 13] - [0, 14]))
                (v [0, 14] - [0, 15]
                  (V [0, 14] - [0, 15]))
                (n [0, 15] - [0, 16]
                  (name [0, 15] - [0, 16]))))))))))
```
 Empty lambda like this `{}` are not allowed in the syntax.

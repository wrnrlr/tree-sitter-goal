# 4.3 Syntax #
## 4.3.1 Is Goal space-insensitive? #
Goal is space-insensitive for the most part, except in a few cases where they’re either needed or forbidden to disambiguate:

A space on at least one of the dot sides disambiguates n-ary application a . b from a variable name a.b with dot-prefix. Also, field syntax a..b binds identifiers tightly.

No space is allowed between a verb or noun and the adverb that modifies it. Otherwise /, \ and ' would get their non-adverb syntax meanings: commenting, logging, and early-return on error.

In an assignment operation, no space is allowed between the operator and the colon.

In bracket indexing, like in f[x;y], no space is allowed between the indexed (or applied) value and the left bracket [. Otherwise the code between brackets would be parsed as a sequence instead.

When minus - is followed by a number with no space in between and also doesn’t tightly follow a noun, it’s parsed as a single token with the number and not as a verb.

No space is allowed between the quoting construct name, like qq or rx, and the starting delimiter. This shouldn’t come as a surprise, but Perl allows such a fancy thing, so I’m mentioning it for exhaustivity :-)

Other than those few cases, you are free to use spacing in the way that seems the most readable for you.

## 4.3.2 What’s the difference between newline and semicolon? #
As stated in the help, newlines are ignored after any of ({[ or before )}] but act as semi-colons otherwise. There’s still one minor difference: duplicate newlines are ignored so that it’s possible to freely use spacing and comments within a multi-line list.

## 4.3.3 Is : syntax or an operator? #
Colon can represent various things in Goal: early return, a verb returning its right argument, assignment syntax, or either a monadic verb or modified assignment marker when tightly following an operator (like in +:). Despite all those different uses, there’s no confusion in practice.

The assignment or modified assignment meaning is used when it follows an identifier like x, an indexing L-value like x[i], or a list of identifiers like (a;b;c) (only plain assignment). If the colon is followed by indexing brackets, the verb meaning is used. When there is an expression on the right, but no noun on the left, a single colon means “return”.

## 4.3.4 What are parens used for? #
Goal uses parens for two things: list creation and controlling operation precedence. List creation happens when one or more semicolons ; appear within parens. The semicolon is used as item separator, and items are evaluated left-to-right. Otherwise, the parens are used to control precedence of operations, as is usual in mathematics and most languages. Lists with a single item are created using the “enlist” monadic form ,x.

As a special case, a couple of lone parens () represents an empty generic list. Note that other kinds of empty lists don’t have a special syntax and have to be produced using primitives: an empty list of integers is !0, an empty list of strings is !"", and an empty list of floats is ?0. While not syntax, those forms are currently optimized by a basic constant-folding pass.

## 4.3.5 How do you write a delimited comment? #
Comments in Goal are either line or multi-line based, there are no C-style delimited block comments allowing to control both comment start and end within a line. However, the discard `expr form that allows to ignore the expression on the right can be used for similar purposes. As a special case, (`expr) is not parsed as an empty generic list, but is completely ignored instead. This can be used to even more finely control the portion of the code that should be ignored, when necessary.

Also, the special x:expr form with literal number or string x can be used as a sort of prefix comment before an expression: it is recognized and optimized, so there’s no runtime overhead.

## 4.3.6 Which number and string literal syntax is supported? #
Number literals are based on Go’s integer and floating-point literals. Goal first attemps to parse a number literal as a 64-bit integer using ParseInt (with automatic base recognition based on string prefix), then as a 64-bit float using ParseFloat, or as a 64-bit integer duration using ParseDuration. Moreover, Goal introduces special literals for a few specific numeric values: 0i for the smallest 64-bit integer value, 0n for NaN, 0w for positive infinity, and -0w for negative infinity.

Double-quoted string literals are similar to Go’s too, as described in the specification, but they can be multi-line and support variable interpolation using $var or ${var}, meaning that a literal $ needs to be escaped. The qq/STRING/ form accepts the same syntax as double-quoted strings, but supports a custom delimiter, as described in the help. The rq/STRING/ is a raw string literal variant supporting a custom delimiter that can still be inserted, but by doubling it instead of by using a backslash.

## 4.3.7 Which regexp syntax is supported? #
The syntax for regexps is the same as the one described in the regexp/syntax Go package, using the default Perl-like syntax. As an extension, Goal allows multi-line regexps when using the quoting construct rx/PATTERN/. In multi-line regexp literals, leading and trailing spaces on each line are ignored, and space followed by / (or # if / is already used as the regexp delimiter) starts a comment that spans until the end of the line.

## 4.3.8 How do variable scoping rules work? #
Variable scoping rules in Goal are simple: variables are either global or local to a lambda function. In other words, Goal has global scope and function scope. There is no concept of block, and nested functions don’t have access to their parent’s scope (see related question about the lack of closures).

Within a lambda, single-colon assignment defines local variables, so globals have to be assigned using double-colon :: there. A global variable can still be accessed, but priority is given to the local variable in case of naming conflict. Note, however, that assignment operations aren’t ambiguous, so :: isn’t needed for them. Also, local variable names cannot have dots in them, so :: isn’t needed either for global names with dots.

Note: a related question is that keywords and variables share the same namespace in source code: keywords are resolved early during scanning and take priority over variable names. They are fixed and cannot be reassigned in any way from Goal code.

## 4.3.9 How do tacit compositions work? #
Goal’s tacit compositions are similar to other K dialects, but they are just sugar for a lambda or a lambda projection. A composition is formed from any kind of expression that ends in a verb: it simply produces an equivalent function with the implicit arguments added at the end. If the last verb is monadic, the function takes just one argument x. If it is dyadic, the function takes two arguments x and y. Both dyadic built-in operators and derived verbs can be made monadic by appending a : without spacing. Dyadic keyword verbs can be made monadic by adding :: at the end. Note that arity in tacit compositions is a syntactic notion unrelated to the semantic concept of function rank.

Most compositions translate easily into a lambda, but when compositions make use of non-constant expressions, they are represented as a lambda projection. In particular, compositions do not capture global variables: those get automatically passed as extra arguments.

Some array languages support more complex tacit features, like BQN or J. Those features carry some cognitive overhead, at least for me. I find the regular switching between explicit and tacit styles distracting.

## 4.3.10 How do .. and field expressions work? #
Double dot .. is syntax sugar that can be used for several purposes, but the main motivation is allowing concise evaluation of expressions under a dict by referring to values using string keys as unquoted variable names.

The simplest case is a tight bind between identifiers as in x..a, which is parsed as a single token and expands to x["a"]. There’s a special consideration with respect to bracket indexing as in x..a[y], which expands to x["a";y] instead of x["a"][y]. In the common case where x holds a dict to some nested array, the result is the same, but merging both applications is closer to how one would write such cases by hand without using the .. syntactic sugar, and it also simplifies making extensions with new kinds of values callable in a method-like style (for example an hypothetical heap value type could be made usable as in x..push[y]). You can write (x..a)[y] to prevent this merging behavior when appropriate.

When .. is not tightly surrounded by two identifiers, as in x .. expr where x can be any kind of expression, a more general expansion is performed: if provided, x is passed as a single argument to a lambda (or lambda projection) described by expr using special variable scoping rules, without braces. Any variable named a (without dot-prefix and not among x, y, z, and o) appearing in expr expands to x..a, that is x["a"]. Variables with a p. prefix are passed as extra projection arguments from the parent context (without the prefix), while variables with a q. quoting prefix are inserted as-is (without the prefix). Other kinds of dot-prefixed names always represent globals and don’t get any kind of special treatment. Note that those expansion rules are not only convenient for concise dict manipulation but also sometimes for concise definition of lambda projections without having to explicitly pass local variables from a parent context as extra arguments.

When .. is tightly followed by an opening bracket [, we get unquoted assignment-style syntax for dict amend d..[a:e1;b:e2], that expands to @[x;"a""b";:;x..(e1;e2)], which is further expanded following the field expression expansion rules already described. When d is not provided, the syntax is simply used as dict creation syntax, expanding directly to "a""b"!(e1;e2), as already shown in the help. As a special case, when keys are provided without a corresponding value in dict creation, as in ..[a;b], the value is assumed to come from a variable named as that key, expanding to ..[a:a;b:b], that is "a""b"!(a;b). This is useful to create a dict from a few variables by using their names as keys without naming redundancy.

Practical examples of the various kinds of usages for .. can be found in the Working with tables chapter.

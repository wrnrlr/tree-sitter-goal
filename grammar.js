const delimited = s => choice(...['/', '#', '`', '"', "'", '%'].map(d => seq(s, token.immediate(d), new RegExp(`[^${d}]*`), d)))
module.exports = grammar({
  name: 'goal',
  supertypes: $ => [$.atom, $.N, $.t, $.e],
  conflicts: $ => [[$.n, $.strand], [$.strand], [$.atom, $.args], [$.e, $.t], [$.v, $.n], [$.nve], [$.v, $.a]],
  extras: $ => [/[\t ]+/, $.inline_comment, $.block_comment],
  rules: {
    S: $ => optional($.E),
    E: $ => repeat1(choice($.e, token('\n'), token(';'))),
    e: $ => prec.right(choice($.nve, $.block, $.v, $.n, $.te, $.implicit)),
    nve: $ => prec(1, seq($.n, $.v, optional($.e))),
    te: $ => prec.right(seq($.t, $.e)),
    t: $ => prec.right(choice($.n, $.v)),
    v: $ => choice($.a, $.V, $.A),
    n: $ => choice($.apply, $.strand, $.N, $.a),
    N: $ => choice($.atom, $.group, $.lambda),
    V: _ => /::|[:+\-*%!&|<>=~,^#_$?@.]/,
    A: _ => token(choice('/', '\\', "'")),
    a: $ => seq($.V, $.A),
    implicit: $ => prec(1, seq($.lambda, $.e)),
    atom: $ => choice($.nil, $.infinity, $.binairy, $.int, $.number, $.hex, $.exponential, $.duration, $.name, $.string, $.qq, $.rq, $.rx),
    strand: $ => seq($.N, repeat1($.N)),
    block: $ => seq('[', optional($.E), ']'),
    apply: $ => seq($.t, token.immediate('['), optional($.E), ']'),
    group: $ => seq('(', optional($.E), ')'),
    lambda: $ => seq('{', optional($.args), optional($.E), '}'),
    args: $ => seq('[', $.name, repeat(seq(';', $.name)), ']'),
    nil: _ => /0[in]/,
    infinity: _ => /-?0w/,
    string: _ => seq('"', repeat(choice(/[^"\\]/, seq('\\', /./))), '"'),
    qq: _ => delimited('qq'),
    rq: _ => delimited('rq'),
    rx: _ => delimited('rx'),
    binairy: _ => token(/0b[01]+/),
    int: _ => token(/-?\d+/),
    number: _ => token(/-?\d+\.\d+/),
    hex: _ => token(/-?0x[\da-f]+/i),
    exponential: _ => token(/-?\d+e[+-]?\d+/i),
    name: _ => /[a-zA-Z_π][\w_π]*/,
    duration: _ => token(/-?(\d+(?:\.\d+)?(?:e[+-]?\d+)?[hms])+/),
    inline_comment: _ => token(/[\t ]+\/[^\n]*/),
    block_comment: _ => token(/\/(?:\n.*)*?\n\\/),
    // line_comment: _ => /\/[^\n]*/,
  }
})
